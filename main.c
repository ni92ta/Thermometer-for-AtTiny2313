/*
 * main.c
 *Термометр на ATtiny 2313
 * Created: 3/10/2022 7:28:52 PM
 *  Author: Никита
 *Личные неимущественные и имущественные права принадлежат автору в случае патентоспособности НТ или её частей.
 */ 

//#include <xc.h>
//#include <avr/interrupt.h>
//#define F_CPU 4800000L
//#include <util/delay.h>
#include "main.h"
unsigned char start_tim;//флаг запуска таймера 0-старт,1-стоп
unsigned char start_run_fraim;//флаг запуска бегущей строки
unsigned char time_tim;//переменная для счёта переполнения таймера
unsigned char start_izm;//переменная для начала измерения температуры
//int e;
//int i;
//int j;
int l;
int y;
int v;
//int g;
//int tt;
//int p;
//int vvvv;
//unsigned char fraim;
//char dtt;
unsigned char t;//Датчик внутренний
unsigned char t2;//Датчик внешний
//unsigned char ttt;
unsigned char aa;
unsigned char bb;
unsigned char cc;
unsigned char vpo;
//unsigned char klll;
unsigned char kll;
//unsigned int ttci;
unsigned char ch;
unsigned char chh;
unsigned char chhh;
//----------------------------------------------------
int efi[12] = {0b01111110,0b00110000,0b01101101,0b01111001,0b00110011,0b01011011,0b01011111,0b01110000,0b01111111,0b01111011,0b01001110,0b00000000
};//0,1,2,3,4,5,6,7,8,9,С,NULL
/*int eff1[12] = {0b00000000,0b01111110,0b00110000,0b01101101,
	            0b01111001,0b00110011,0b01011011,0b01011111,
				0b01110000,0b01111111,0b00000000,0b00000000
};*/
//int efi[9] = {0b00000000,0b01111110,0b00110000,0b01101101,0b01111001,0b00000000,0b00000000,0b00000000,0b00000000
//};
//int eff1[9] = {0b00000000,0b01111110,0b00110000,0b01101101,0b01111001,0b00000000,0b00000000,0b00000000,0b00000000
	//};
int eff1[9] = {0};
int buf[9];//Буфер для хранения сдвигаемой матрицы. Размер равен размеру матрицы с текстом
 //-----------------------функция-инициализации таймера------
 void timer_ini(void)
 {
	TCCR0A |= (1<<WGM01);//устанавливаем режим работы таймера - сброс при совпадении 0b00000010
	TCCR0B |= (1<<CS02) | (1<<CS00) ;//устанавливаем делитель 1024	
	TCNT0 = 0b00000000;//обнуляем таймер 
	//TIMSK = 0b00000001;//|= (1<<OCIE0A);//устанавливаем бит разрешения прерывания счетчика по совпадению
	//TIMSK0 =0b00000000;//&= ~0x01;
	TCNT0 = 0b00000000;// установка начального значения таймера 11101000
	OCR0A = 0b00010110;//записываем в регистр число для сравнения	00110010
	//TIMSK |=  (1<<OCIE0A);//устанавливаем бит разрешения прерывания таймера по совпадению  (1<<TOIE0) |
	//TCCR0B |= (1<<CS02) | (1<<CS00);
 }
 //--------------Вывод информации на индикатор-----------
 /*void out_led (int kl)
 {
	  unsigned char ch = (kl%10);//единицы
	  unsigned char chh = kl%100/10;//десятки
	  unsigned char chhh = kl%1000/100;//сотни
	 for (int i = 1; i>=0; i--)
	 {
		  PORTB = eff1[ch];//третья цифра
		  PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
		  PORTD &= ~(1<<0);//третий сегмент
		  _delay_ms(5);
		  PORTB = eff1[chh];//вторая цифра
		  PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
		  PORTD &= ~(1<<1);//второй сегмент
		  _delay_ms(2);
		  PORTB = eff1[chhh];//первая цифра
		  PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
		  PORTD &= ~(1<<2);//первый сегмент
		  _delay_ms(2);
	 }
 }*/
 //------------функция-обработчик таймера-------------
 ISR (TIMER0_COMPA_vect)//	TIMER0_COMPA_vect   
 {
time_tim++;
	 TIMSK = 0b00000000;
	 TCCR0B = 0b00000000;//останавливаем таймер
 }
//------------Перевод двоичного результата в десятичный----
//void digit_convert ()
//-------------Вывод фрейма---------------------------
void fraim_out (void){
							
	if (time_tim==20){//задаём время до начала бегущей строки 40~20сек 
		start_run_fraim=0;
		start_tim = 1;
		 time_tim=0;
		 //kll=0;	 
	}


	start_run_fraim++;
	 //kll=0;	
 if (start_run_fraim<=10) {//количество проходов бегущей строки 20~2раза
	 buf[9] = eff1[1]; // Считали 1ю колонку в буфер
	 for (int v = 1; v<=10; v++)
	 {
		 vpo ++;
		 eff1[v] = eff1[v+1]; // Сдвинули матрицу на один столбец влево
		
	 }
	 eff1[9] = buf[9]; // Записали содержимое буфера (первую колонку) в конец матрицы
	 
	  switch (vpo)
		 {
			 case 10:
			  eff1[1] = 0;//0
			  eff1[2] = cc;//1
			  eff1[3] = bb;//2
			  eff1[4] = aa;//3
			  eff1[5] = 0b01001110;//4
			 break;
			 			 case 20:
						 eff1[1] = cc;//0
			             eff1[2] = bb;//2
			             eff1[3] = aa;//3
			             eff1[4] = 0b01001110;//4
			             eff1[5] = 0;//0
			  			 eff1[6] = 0;//0
			  			 eff1[7] = 0;//0
			  			 eff1[8] = 0;//0
			  			 eff1[9] = 0;//0
			 			 break;
						  			 case 30:
						 eff1[1] = bb;//0
						 eff1[2] = aa;//2
						 eff1[3] = 0b01001110;//3
						 eff1[4] = 0;//4
						 eff1[5] = 0;//0
						 eff1[6] = 0;//0
						 eff1[7] = 0;//0
						 eff1[8] = 0;//0
						 eff1[9] = cc;//0
						  			 break;
						case 40:

						 eff1[1] = aa;//0
						 eff1[2] = 0b01001110;//2
						 eff1[3] = 0;//3
						 eff1[4] = 0;//4
						 eff1[5] = 0;//0
						 eff1[6] = 0;//0
						 eff1[7] = 0;//0
						 eff1[8] = cc;//0
						 eff1[9] = bb;//0
									   			 break;
						 case 50:
						   if (kll==1){
							   t = dt_check(2); //измеряем температуру внешнего датчика
							  
						   }
						  if (kll==0){
							  t = dt_check(1);//измеряем температуру внутреннего датчика
							 // kll=1;
						  }
						  						
							  ch = t%10;//единицы
							  chh = t%100/10;//десятки
							  chhh = t%1000/100;//сотни
							  aa = efi[ch];
							  bb = efi[chh];
							  if (chhh == 0){//убираем первый разряд (ноль)
								  cc = efi[12];
							  }
							  else{
								  cc = efi[chhh];
							  }
						  
						 eff1[1] = 0b01001110;//0
						 eff1[2] = 0;//2
						 eff1[3] = 0;//3
						 eff1[4] = 0;//4
						 eff1[5] = 0;//0
						 eff1[6] = 0;//0
						 eff1[7] = cc;//cc
						 eff1[8] = bb;//bb
						 eff1[9] = aa;//aa
						  

						 
																 break;
								 case 60:
								 eff1[1] = 0b00000000;//0 
							     eff1[2] = 0b00000000;//0
							     eff1[3] = 0b00000000;//0
								 eff1[4] = 0b00000000;//0
								 eff1[5] = 0b00000000;//0
								 eff1[6] = 0b00000000;//0						
								 break;
			 
								case 110:					 
			  eff1[1] = 0;//0
			  eff1[2] = cc;//1
			  eff1[3] = bb;//2
			  eff1[4] = aa;//3
			  eff1[5] = 0b01001110;//4
			  vpo = 10;
			  // kll=0;	
				break;																
		 } 
 }
	for (int i = 0; i < 350; ++i) {
		PORTB = eff1[l];
		_delay_us(500);//пауза для задания скорости движения бегущей строки 1000us
		switch (l){
			case 0:
			PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
			break;
			case 1:
			PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
			PORTD &= ~(1<<2);
			break;
			case 2:
			PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
			PORTD &= ~(1<<1);
			break;
			case 3:
			PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
			PORTD &= ~(1<<0);
			break;
			case 4:
			PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
			PORTD &= ~(1<<3);
			break;
						case 5:
						PORTD |= (1<<3) | (1<<2) | (1<<1) | (1<<0);
						break;
							}
		l++;
		y++;


		if (y == 9) {
			y = 0;
			l -= 9;
			 //kll=0;
			 		v++;
			 		if (v<=1) {
				 		kll = 0;
			 		}
			 		if (v>=2){
							if (v>=3) v=0;
						kll=1;  
					 }
			
					 		                            if (start_run_fraim>=20){
															 // kll=0;	
														  eff1[2] = cc;//2
					 		                             eff1[3] = bb;//2
					 		                             eff1[4] = aa;//3
					 		                             eff1[5] = 0b01001110;//4
														 }
														  //kll=0;	
			}
			}


	
if (start_tim == 0){
		TIMSK |= (1<<OCIE0A);//устанавливаем бит разрешения прерывания таймера по совпадению
		TCCR0B |= (1<<CS02) | (1<<CS00);
		TCNT0 = 0b00000000;//обнуляем таймер
		// kll=0;									 
}
}
//-----------------------------------------------------
int main(void)
{
    sei();//разрешаем глобальные прерывания
	DDRB = 0b11111111;// определяем выходы мк (1 выход; 0 вход); 
	DDRD = 0b01001111;// определяем выходы мк (1 выход; 0 вход);
    while(1)
    {	

		fraim_out();
		 //kll=0;	

		
	}
}
//PORTB |= 0x10;//установка бита
//PORTB &= ~0x1;//сброс бита

